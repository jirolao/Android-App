"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.loadAsset = exports.default = void 0;

var _webgltextureLoader = require("webgltexture-loader");

var _reactNative = require("react-native");

var FileSystem = _interopRequireWildcard(require("expo-file-system"));

var _expoAsset = require("expo-asset");

var _md = _interopRequireDefault(require("./md5"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }

function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

const neverEnding = new Promise(() => {});

const hash = module => typeof module === "number" ? module : module.uri;

const localAsset = module => {
  const asset = _expoAsset.Asset.fromModule(module);

  return asset.downloadAsync().then(() => asset);
};

const remoteAssetCache = {};

const remoteAsset = uri => {
  const i = uri.lastIndexOf(".");
  const ext = i !== -1 ? uri.slice(i) : ".jpg";
  const key = (0, _md.default)(uri);

  if (key in remoteAssetCache) {
    return Promise.resolve(remoteAssetCache[key]);
  }

  const promise = Promise.all([new Promise((success, failure) => _reactNative.Image.getSize(uri, (width, height) => success({
    width,
    height
  }), failure)), FileSystem.downloadAsync(uri, FileSystem.documentDirectory + `ExponentAsset-${key}${ext}`, {
    cache: true
  })]).then(([size, asset]) => _objectSpread(_objectSpread({}, size), {}, {
    uri,
    localUri: asset.uri
  }));
  remoteAssetCache[key] = promise;
  return promise;
};

const localFile = uri => {
  const i = uri.lastIndexOf(".");
  const ext = i !== -1 ? uri.slice(i) : ".jpg";
  const key = (0, _md.default)(uri);

  if (key in remoteAssetCache) {
    return Promise.resolve(remoteAssetCache[key]);
  }

  const promise = new Promise((success, failure) => _reactNative.Image.getSize(uri, (width, height) => success({
    width,
    height
  }), failure)).then(size => _objectSpread(_objectSpread({}, size), {}, {
    uri,
    localUri: uri
  }));
  remoteAssetCache[key] = promise;
  return promise;
};

const loadAsset = module => typeof module === "number" ? localAsset(module) : module.uri.startsWith("file:") || module.uri.startsWith("data:") || module.uri.startsWith("asset:") || // All local paths in Android Expo standalone app
module.uri.startsWith("assets-library:") || // CameraRoll.getPhotos iOS
module.uri.startsWith("content:") || // CameraRoll.getPhotos Android
module.uri.startsWith("/") // Expo.takeSnapshotAsync in DEV in Expo 31
? localFile(module.uri) : remoteAsset(module.uri);

exports.loadAsset = loadAsset;

class ExpoModuleTextureLoader extends _webgltextureLoader.WebGLTextureLoaderAsyncHashCache {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "objIds", new WeakMap());
  }

  canLoad(input) {
    return typeof input === "number" || input && typeof input === "object" && typeof input.uri === "string";
  }

  inputHash(module) {
    return typeof module === "number" ? module : module.uri;
  }

  loadNoCache(module) {
    const {
      gl
    } = this;
    let disposed = false;

    const dispose = () => {
      disposed = true;
    };

    const promise = loadAsset(module).then(asset => {
      if (disposed) return neverEnding;
      const {
        width,
        height
      } = asset;
      const texture = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, texture); // $FlowFixMe

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, width, height, 0, gl.RGBA, gl.UNSIGNED_BYTE, asset);
      return {
        texture,
        width,
        height
      };
    });
    return {
      promise,
      dispose
    };
  }

}

_webgltextureLoader.globalRegistry.add(ExpoModuleTextureLoader);

var _default = ExpoModuleTextureLoader;
exports.default = _default;
//# sourceMappingURL=ExpoModuleTextureLoader.js.map